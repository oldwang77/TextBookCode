[并查集&&压缩路径的讲解](http://blog.csdn.net/u013486414/article/details/38682057)
[并查集](http://blog.csdn.net/allen231x/article/details/8538734)

**一.所谓并查集**
 定义：并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。
**既然是并查集，就是解决两个问题：**
A.合并两个集合
B.查找一个元素属于哪个集合


  **并查集的精髓**（即它的三种操作，结合实现代码模板进行理解）：
  
1、Make_Set(x) 把每一个元素初始化为一个集合
初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。

2、Find_Set(x) 查找一个元素所在的集合
查找一个元素所在的集合，**其精髓是找到这个元素所在集合的祖先**！**这个才是并查集判断和合并的最终依据。**
**判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。**
**合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。**

3、Union(x,y) 合并x,y所在的两个集合

合并两个不相交集合操作很简单：利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。

**二.并查集的优化**

1、Find_Set(x)时 路径压缩
寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？
答案是肯定的，这就是路径压缩，即当我们经过"递推"找到祖先节点后，"回溯"的时候顺便将它的子孙节点都直接指向祖先，这样以后再次Find_Set(x)时复杂度就变成O(1)了，可见，路径压缩方便了以后的查找。
 
2、Union(x,y)时 按秩合并
即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。

下面给出并查集的核心代码：

```
#include<stdio.h>
const int maxn=100; //结点数目上线
int pa[maxn]; //p[x]代表x的父节点
int rank[maxn]; //rank[x]是x的高度的上界

void make_set(int x){
//创建一个单元素集
	pa[x]=x;
	rank[x]=0;
}

int find_set(int x){   //返回x所在的集合代表（及元素根结点的下标）
//带路径的压缩的查找
	if(x!=pa[x])
		pa[x]=find_set(p[x]);
	return pa[x];
}

void union_set(int x,int y){//按秩合并x,y所在的集合
	x=find_set(x);
	y=find_set(y);
	if(rank[x]>rank[y]) //取rank较高的作为父节点
		pa[y]=x;
	else{
		pa[x]=y;
		if(rank[x]==rank[y])
			rank[y]++;
	}
}
```