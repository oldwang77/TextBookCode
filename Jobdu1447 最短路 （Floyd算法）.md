>Floyd算法简介：
1.用**邻接矩阵**保存原图，其中edge[i][j]表示由i直接到j的最小值。然后中间路径增加结点K（遍历中间允许加入结点1，2，3，4，5.....N），比较edge[i][j]和edge[i][k]+edge[k][j]的大小，取较小的。
2.Floyd算法解决的是全源最短路径，及任意两点之间的最短路径，而Dijkstra算法，解决的单源最短路径问题，这就是两者间的一个最主要的差别。
3.Floyd算法的时间复杂度为O（N^3）,它解决的题目不能超过200个结点。

题目描述： 
在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？
输入： 
输入包括多组数据。每组数据第一行是两个整数N、M（N<=100，M<=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1<=A,B<=N,1<=C<=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。
当输入为两个0时，输入结束。
输出： 
对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间。
样例输入： 
2 1
1 2 3
3 3
1 2 5
2 3 5
3 1 2
0 0
样例输出： 
3
2

```
#include<iostream>
using namespace std;
int ans[101][101];
int main(){
	int n,m,i,j,k;
	while(cin>>n>>m){
		if(n==0&&m==0) break;
		for(i=1;i<=n;i++){  //n个结点,m条路
			for(j=1;j<=n;j++){
				ans[i][j]=-1;
			}
			ans[i][i]=0;
		}
		while(m--){
			int a,b,c;
			cin>>a>>b>>c;
			ans[a][b]=ans[b][a]=c;
		}
		for(k=1;k<=n;k++){
			for(i=1;i<=n;i++){
				for(j=1;j<=n;j++){ //遍历ans[i][j]，
									//判断其值是保持不变还是更新
					if(ans[i][k]==-1||ans[k][j]==-1) continue;
					if(ans[i][j]==-1||ans[i][k]+ans[k][j]<ans[i][j])
						ans[i][j]=ans[i][k]+ans[k][j];
				}
			}
		}
		printf("%d\n",ans[1][n]);
	}
return 0;
}
```